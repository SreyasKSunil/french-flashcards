<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>French Flashcards</title>
  <style>
    :root { color-scheme: light dark; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 16px;
      max-width: 900px;
      margin-left: auto;
      margin-right: auto;
      line-height: 1.35;
    }
    h1 { font-size: 20px; margin: 0 0 10px 0; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .card {
      border: 1px solid rgba(127,127,127,0.35);
      border-radius: 14px;
      padding: 16px;
      min-height: 180px;
      display: grid;
      gap: 10px;
      user-select: none;
      cursor: pointer;
    }
    .muted { opacity: 0.75; font-size: 13px; }
    .big { font-size: 26px; font-weight: 650; }
    .mid { font-size: 16px; }
    .pill {
      border: 1px solid rgba(127,127,127,0.35);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 13px;
    }
    button, input[type="file"] {
      font-size: 14px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(127,127,127,0.35);
      background: transparent;
    }
    button { cursor: pointer; }
    button.primary { font-weight: 650; }
    .grid { display: grid; gap: 12px; }
    .rate { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
    .rate button { padding: 12px 8px; }
    .panel {
      border: 1px solid rgba(127,127,127,0.35);
      border-radius: 14px;
      padding: 12px;
    }
    textarea {
      width: 100%;
      min-height: 120px;
      border-radius: 12px;
      border: 1px solid rgba(127,127,127,0.35);
      padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
    }
    .two { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 860px) {
      .two { grid-template-columns: 1.2fr 0.8fr; }
    }
    .footer { margin-top: 12px; display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .warn { color: #b00020; }
    .ok { color: #0a7a2f; }
  </style>
</head>
<body>
  <h1>French Flashcards A2 to B2</h1>

  <div class="two">
    <div class="grid">
      <div class="row">
        <span class="pill" id="deckInfo">Deck: 0 cards</span>
        <span class="pill" id="dueInfo">Due: 0</span>
        <span class="pill" id="streakInfo">Today: 0 reviews</span>
      </div>

      <div class="card" id="card" title="Tap to flip">
        <div class="muted" id="cardTop">Import a deck to begin</div>
        <div class="big" id="frontText">No cards loaded</div>
        <div class="mid" id="backText" style="display:none"></div>
        <div class="muted" id="exampleText" style="display:none"></div>
        <div class="muted" id="notesText" style="display:none"></div>
        <div class="row">
          <button id="speakBtn" type="button">Audio FR</button>
          <button id="nextBtn" type="button" class="primary">Next</button>
        </div>
      </div>

      <div class="rate panel">
        <button id="againBtn" type="button">Again</button>
        <button id="hardBtn" type="button">Hard</button>
        <button id="goodBtn" type="button">Good</button>
        <button id="easyBtn" type="button">Easy</button>
      </div>

      <div class="panel">
        <div class="row">
          <button id="startA2Btn" type="button">Load starter A2 daily deck</button>
          <button id="exportBtn" type="button">Export CSV</button>
          <button id="resetBtn" type="button">Reset data</button>
        </div>
        <div class="muted" id="status"></div>
      </div>
    </div>

    <div class="grid">
      <div class="panel">
        <div class="row">
          <input id="fileInput" type="file" accept=".csv,.txt,.xml" />
          <button id="importBtn" type="button" class="primary">Import</button>
        </div>
        <div class="muted">
          CSV headers: front,back,example,notes
        </div>
      </div>

      <div class="panel">
        <div class="row">
          <button id="pasteLoadBtn" type="button">Load from pasted CSV</button>
          <button id="pasteClearBtn" type="button">Clear</button>
        </div>
        <textarea id="pasteBox" placeholder="Paste CSV here, then press Load"></textarea>
      </div>

      <div class="panel">
        <div class="muted">
          Audio uses device voices. If French voice is missing, add a French voice in iOS or macOS settings.
        </div>
        <div class="muted warn" id="audioWarn" style="display:none"></div>
        <div class="muted ok" id="audioOk" style="display:none"></div>
      </div>
    </div>
  </div>

  <script>
    const storageKey = "ff_deck_v1"
    const storageStatsKey = "ff_stats_v1"

    const byId = id => document.getElementById(id)

    const ui = {
      deckInfo: byId("deckInfo"),
      dueInfo: byId("dueInfo"),
      streakInfo: byId("streakInfo"),
      card: byId("card"),
      cardTop: byId("cardTop"),
      frontText: byId("frontText"),
      backText: byId("backText"),
      exampleText: byId("exampleText"),
      notesText: byId("notesText"),
      status: byId("status"),
      fileInput: byId("fileInput"),
      pasteBox: byId("pasteBox"),
      audioWarn: byId("audioWarn"),
      audioOk: byId("audioOk")
    }

    const state = {
      deck: [],
      current: null,
      showBack: false,
      queue: [],
      lastPickId: null
    }

    const todayKey = () => {
      const d = new Date()
      const y = d.getFullYear()
      const m = String(d.getMonth() + 1).padStart(2, "0")
      const day = String(d.getDate()).padStart(2, "0")
      return `${y}-${m}-${day}`
    }

    const loadStats = () => {
      const raw = localStorage.getItem(storageStatsKey)
      if (!raw) return { day: todayKey(), reviews: 0 }
      try {
        const s = JSON.parse(raw)
        if (s.day !== todayKey()) return { day: todayKey(), reviews: 0 }
        return s
      } catch {
        return { day: todayKey(), reviews: 0 }
      }
    }

    const saveStats = stats => localStorage.setItem(storageStatsKey, JSON.stringify(stats))

    const nowTs = () => Date.now()

    const clamp = (n, a, b) => Math.max(a, Math.min(b, n))

    const normalizeCard = (c, idx) => {
      const base = {
        id: c.id || `c_${nowTs()}_${idx}_${Math.random().toString(16).slice(2)}`,
        front: (c.front || "").trim(),
        back: (c.back || "").trim(),
        example: (c.example || "").trim(),
        notes: (c.notes || "").trim(),
        createdAt: c.createdAt || nowTs(),
        updatedAt: nowTs(),
        dueAt: c.dueAt || nowTs(),
        intervalDays: typeof c.intervalDays === "number" ? c.intervalDays : 0,
        ease: typeof c.ease === "number" ? c.ease : 2.3,
        reps: typeof c.reps === "number" ? c.reps : 0,
        lapses: typeof c.lapses === "number" ? c.lapses : 0
      }
      return base
    }

    const saveDeck = () => localStorage.setItem(storageKey, JSON.stringify(state.deck))

    const loadDeck = () => {
      const raw = localStorage.getItem(storageKey)
      if (!raw) return []
      try {
        const arr = JSON.parse(raw)
        if (!Array.isArray(arr)) return []
        return arr.map(normalizeCard)
      } catch {
        return []
      }
    }

    const dueCount = () => state.deck.filter(c => c.dueAt <= nowTs()).length

    const refreshBadges = () => {
      ui.deckInfo.textContent = `Deck: ${state.deck.length} cards`
      ui.dueInfo.textContent = `Due: ${dueCount()}`
      const stats = loadStats()
      ui.streakInfo.textContent = `Today: ${stats.reviews} reviews`
    }

    const renderCard = () => {
      refreshBadges()

      if (!state.current) {
        ui.cardTop.textContent = "Import a deck to begin"
        ui.frontText.textContent = "No cards loaded"
        ui.backText.style.display = "none"
        ui.exampleText.style.display = "none"
        ui.notesText.style.display = "none"
        ui.status.textContent = ""
        return
      }

      ui.cardTop.textContent = `Due ${new Date(state.current.dueAt).toLocaleString()}  Ease ${state.current.ease.toFixed(2)}  Interval ${state.current.intervalDays.toFixed(2)}d`
      ui.frontText.textContent = state.current.front || "(empty)"
      ui.backText.textContent = state.current.back || "(empty)"
      ui.exampleText.textContent = state.current.example ? `Example: ${state.current.example}` : ""
      ui.notesText.textContent = state.current.notes ? `Notes: ${state.current.notes}` : ""

      ui.backText.style.display = state.showBack ? "block" : "none"
      ui.exampleText.style.display = state.showBack && state.current.example ? "block" : "none"
      ui.notesText.style.display = state.showBack && state.current.notes ? "block" : "none"
    }

    const pickNext = () => {
      if (!state.deck.length) {
        state.current = null
        state.showBack = false
        renderCard()
        return
      }

      const due = state.deck.filter(c => c.dueAt <= nowTs())
      const pool = due.length ? due : state.deck

      let pick = pool[Math.floor(Math.random() * pool.length)]
      if (pool.length > 1 && state.lastPickId) {
        let guard = 0
        while (pick.id === state.lastPickId && guard < 10) {
          pick = pool[Math.floor(Math.random() * pool.length)]
          guard += 1
        }
      }

      state.current = pick
      state.lastPickId = pick.id
      state.showBack = false
      renderCard()
    }

    const rate = level => {
      if (!state.current) return

      const c = state.current
      const stats = loadStats()

      c.reps += 1
      c.updatedAt = nowTs()

      if (level === "again") {
        c.lapses += 1
        c.ease = clamp(c.ease - 0.20, 1.3, 2.8)
        c.intervalDays = 0
        c.dueAt = nowTs() + 2 * 60 * 1000
      }

      if (level === "hard") {
        c.ease = clamp(c.ease - 0.10, 1.3, 2.8)
        const base = c.intervalDays <= 0 ? 0.25 : c.intervalDays
        c.intervalDays = clamp(base * 1.2, 0.15, 365)
        c.dueAt = nowTs() + c.intervalDays * 24 * 60 * 60 * 1000
      }

      if (level === "good") {
        const base = c.intervalDays <= 0 ? 0.5 : c.intervalDays
        c.intervalDays = clamp(base * c.ease, 0.25, 365)
        c.dueAt = nowTs() + c.intervalDays * 24 * 60 * 60 * 1000
      }

      if (level === "easy") {
        c.ease = clamp(c.ease + 0.10, 1.3, 2.8)
        const base = c.intervalDays <= 0 ? 1 : c.intervalDays
        c.intervalDays = clamp(base * (c.ease + 0.25), 0.5, 365)
        c.dueAt = nowTs() + c.intervalDays * 24 * 60 * 60 * 1000
      }

      saveDeck()

      stats.reviews += 1
      saveStats(stats)

      pickNext()
    }

    const parseCSVLine = line => {
      const out = []
      let cur = ""
      let inQuotes = false
      for (let i = 0; i < line.length; i += 1) {
        const ch = line[i]
        if (ch === '"') {
          const next = line[i + 1]
          if (inQuotes && next === '"') {
            cur += '"'
            i += 1
          } else {
            inQuotes = !inQuotes
          }
        } else if (ch === "," && !inQuotes) {
          out.push(cur)
          cur = ""
        } else {
          cur += ch
        }
      }
      out.push(cur)
      return out.map(s => s.trim())
    }

    const parseCSV = text => {
      const lines = text.replace(/\r/g, "").split("\n").filter(l => l.trim().length)
      if (!lines.length) return []

      const header = parseCSVLine(lines[0]).map(h => h.toLowerCase())
      const idx = name => header.indexOf(name)
      const iFront = idx("front")
      const iBack = idx("back")
      const iExample = idx("example")
      const iNotes = idx("notes")

      if (iFront < 0 || iBack < 0) {
        throw new Error("Missing headers. Required: front,back. Optional: example,notes")
      }

      const cards = []
      for (let i = 1; i < lines.length; i += 1) {
        const cols = parseCSVLine(lines[i])
        const c = {
          front: cols[iFront] || "",
          back: cols[iBack] || "",
          example: iExample >= 0 ? (cols[iExample] || "") : "",
          notes: iNotes >= 0 ? (cols[iNotes] || "") : ""
        }
        if (c.front.trim() || c.back.trim()) cards.push(c)
      }
      return cards
    }

    const parseXML = text => {
      const parser = new DOMParser()
      const doc = parser.parseFromString(text, "application/xml")
      const err = doc.querySelector("parsererror")
      if (err) throw new Error("XML parse error")

      const nodes = Array.from(doc.querySelectorAll("card"))
      const cards = nodes.map(n => ({
        front: (n.querySelector("front")?.textContent || "").trim(),
        back: (n.querySelector("back")?.textContent || "").trim(),
        example: (n.querySelector("example")?.textContent || "").trim(),
        notes: (n.querySelector("notes")?.textContent || "").trim()
      })).filter(c => c.front || c.back)

      return cards
    }

    const mergeCards = newCards => {
      const normalized = newCards.map(normalizeCard)
      const existingByKey = new Map(state.deck.map(c => [`${c.front}||${c.back}`, c]))
      let added = 0

      for (const c of normalized) {
        const key = `${c.front}||${c.back}`
        if (existingByKey.has(key)) continue
        state.deck.push(c)
        added += 1
      }

      saveDeck()
      ui.status.textContent = `Imported. Added ${added} cards. Total ${state.deck.length}.`
      pickNext()
    }

    const speakFR = text => {
      ui.audioWarn.style.display = "none"
      ui.audioOk.style.display = "none"

      if (!("speechSynthesis" in window)) {
        ui.audioWarn.textContent = "Speech engine not found in this browser."
        ui.audioWarn.style.display = "block"
        return
      }

      const u = new SpeechSynthesisUtterance(text)
      u.lang = "fr-FR"
      u.rate = 0.95
      u.pitch = 1.0

      const voices = window.speechSynthesis.getVoices ? window.speechSynthesis.getVoices() : []
      const fr = voices.find(v => (v.lang || "").toLowerCase().startsWith("fr"))
      if (fr) u.voice = fr

      window.speechSynthesis.cancel()
      window.speechSynthesis.speak(u)

      ui.audioOk.textContent = fr ? `Voice: ${fr.name}` : "Voice: default"
      ui.audioOk.style.display = "block"
    }

    const exportCSV = () => {
      const rows = []
      rows.push('front,back,example,notes')
      for (const c of state.deck) {
        const esc = s => {
          const t = (s || "").replace(/"/g, '""')
          return /[,"\n]/.test(t) ? `"${t}"` : t
        }
        rows.push([esc(c.front), esc(c.back), esc(c.example), esc(c.notes)].join(","))
      }
      const blob = new Blob([rows.join("\n")], { type: "text/csv;charset=utf-8" })
      const url = URL.createObjectURL(blob)
      const a = document.createElement("a")
      a.href = url
      a.download = "french_flashcards.csv"
      document.body.appendChild(a)
      a.click()
      a.remove()
      URL.revokeObjectURL(url)
    }

    const starterA2 = () => {
      const cards = [
        { front: "Bonjour", back: "Hello", example: "Bonjour, vous allez bien ?", notes: "Greeting" },
        { front: "Bonsoir", back: "Good evening", example: "Bonsoir, je suis en retard.", notes: "" },
        { front: "S’il vous plaît", back: "Please", example: "Une baguette, s’il vous plaît.", notes: "" },
        { front: "Merci", back: "Thank you", example: "Merci pour votre aide.", notes: "" },
        { front: "Je cherche…", back: "I am looking for…", example: "Je cherche la station de métro.", notes: "" },
        { front: "Combien ça coûte ?", back: "How much does it cost?", example: "Combien ça coûte au total ?", notes: "" },
        { front: "Je voudrais", back: "I would like", example: "Je voudrais un café.", notes: "" },
        { front: "Où sont les toilettes ?", back: "Where are the toilets?", example: "Où sont les toilettes, s’il vous plaît ?", notes: "" },
        { front: "J’ai un problème", back: "I have a problem", example: "J’ai un problème avec ma commande.", notes: "" },
        { front: "Je ne comprends pas", back: "I do not understand", example: "Je ne comprends pas. Vous pouvez répéter ?", notes: "" },
        { front: "Pouvez-vous répéter ?", back: "Can you repeat?", example: "Pouvez-vous répéter plus lentement ?", notes: "" },
        { front: "Je suis en train de…", back: "I am in the middle of…", example: "Je suis en train de travailler.", notes: "" },
        { front: "On se retrouve à quelle heure ?", back: "What time do we meet?", example: "On se retrouve à quelle heure devant le café ?", notes: "" },
        { front: "Je rentre", back: "I am going home", example: "Je rentre vers 19h.", notes: "" },
        { front: "J’ai besoin de", back: "I need", example: "J’ai besoin d’un reçu.", notes: "" },
        { front: "C’est possible ?", back: "Is it possible?", example: "C’est possible de payer par carte ?", notes: "" },
        { front: "Je prends", back: "I will take", example: "Je prends celui-ci.", notes: "" },
        { front: "Ça marche", back: "It works, OK", example: "D’accord, ça marche.", notes: "" },
        { front: "À tout à l’heure", back: "See you later", example: "À tout à l’heure au bureau.", notes: "" },
        { front: "Bonne journée", back: "Have a good day", example: "Merci, bonne journée.", notes: "" }
      ]
      mergeCards(cards)
      ui.status.textContent = "Starter deck loaded."
    }

    const initAudioProbe = () => {
      if (!("speechSynthesis" in window)) {
        ui.audioWarn.textContent = "Speech engine not found in this browser."
        ui.audioWarn.style.display = "block"
        return
      }

      const refreshVoices = () => {
        const voices = window.speechSynthesis.getVoices ? window.speechSynthesis.getVoices() : []
        const fr = voices.find(v => (v.lang || "").toLowerCase().startsWith("fr"))
        if (!voices.length) return
        if (!fr) {
          ui.audioWarn.textContent = "No French voice found. Add a French voice in device settings."
          ui.audioWarn.style.display = "block"
        } else {
          ui.audioOk.textContent = `French voice found: ${fr.name}`
          ui.audioOk.style.display = "block"
        }
      }

      refreshVoices()
      if (window.speechSynthesis.onvoiceschanged !== undefined) {
        window.speechSynthesis.onvoiceschanged = refreshVoices
      }
    }

    byId("importBtn").addEventListener("click", async () => {
      const f = ui.fileInput.files && ui.fileInput.files[0]
      if (!f) {
        ui.status.textContent = "Select a file first."
        return
      }
      const text = await f.text()
      try {
        const name = (f.name || "").toLowerCase()
        let cards = []
        if (name.endsWith(".xml")) cards = parseXML(text)
        else cards = parseCSV(text)
        mergeCards(cards)
      } catch (e) {
        ui.status.textContent = `Import error: ${e.message || e}`
      }
    })

    byId("pasteLoadBtn").addEventListener("click", () => {
      const text = ui.pasteBox.value || ""
      try {
        const cards = parseCSV(text)
        mergeCards(cards)
      } catch (e) {
        ui.status.textContent = `Paste import error: ${e.message || e}`
      }
    })

    byId("pasteClearBtn").addEventListener("click", () => {
      ui.pasteBox.value = ""
      ui.status.textContent = ""
    })

    ui.card.addEventListener("click", () => {
      if (!state.current) return
      state.showBack = !state.showBack
      renderCard()
    })

    byId("nextBtn").addEventListener("click", () => pickNext())

    byId("speakBtn").addEventListener("click", () => {
      if (!state.current) return
      const t = state.showBack ? (state.current.example || state.current.front) : state.current.front
      if (!t.trim()) return
      speakFR(t)
    })

    byId("againBtn").addEventListener("click", () => rate("again"))
    byId("hardBtn").addEventListener("click", () => rate("hard"))
    byId("goodBtn").addEventListener("click", () => rate("good"))
    byId("easyBtn").addEventListener("click", () => rate("easy"))

    byId("exportBtn").addEventListener("click", () => exportCSV())

    byId("resetBtn").addEventListener("click", () => {
      localStorage.removeItem(storageKey)
      localStorage.removeItem(storageStatsKey)
      state.deck = []
      state.current = null
      state.showBack = false
      ui.status.textContent = "Reset done."
      renderCard()
    })

    byId("startA2Btn").addEventListener("click", () => starterA2())

    state.deck = loadDeck()
    refreshBadges()
    pickNext()
    initAudioProbe()
  </script>
</body>
</html>

